# :e-mail: Digital Certificates(X.509) and Public-Key Infrastructure (PKI)

A digital certificate is a file that proves authenticity.

Trust is validated using a PKI(Public-Key Infrastructure).

For web usage, a digital certificate is also called a SSL/TLS certificate.
It is used to provide a HTTPS connection between the clients and the services.
When a HTTPS connection is established, trust has been guaranteed that the client and 
the server are authentic and data transfered between them is encrypted.

## Self Signed Certificate 

This section will describe how to create a self-signed SSL/TLS certificate.

It is called a 'self-signed' because the properties 'Issued By(Issuer)' and 'Issued To(Subject)' are the same.

Self-signed certificates are mostly used for development purposes to run a webserver on your localhost 
or, for ease of use, to host services on your home lab inside your private network.

To create one, first generate a RSA or ECDSA private key:
```
openssl genrsa -out selfsigned.pri

openssl ecparam -name secp384r1 -noout -genkey -out selfsigned.pri
```

The follow details represent a minimal set for openssl configuration properties
to be able to create a self signed certificate:
```
[ req ]
default_bits       = 2048
default_md         = sha256
default_days       = 365
distinguished_name = req_distinguished_name
req_extensions     = req_ext
x509_extensions    = v3_ca
prompt             = no

[ req_distinguished_name ]
CN = localhost
O  = Self Generated Certificate 

[ req_ext ]
subjectAltName = @alt_names

[ v3_ca ]
subjectAltName           = @alt_names
basicConstraints         = critical, CA:FALSE
keyUsage                 = critical, digitalSignature, keyEncipherment
extendedKeyUsage         = critical, serverAuth
1.3.6.1.4.1.311.84.1.1   = DER:02

[ alt_names ]
DNS.1   = localhost
DNS.2   = 127.0.0.1
```

Create a file called `selfsigned.cnf` with the contents from above.

Generate the self-signed certificate with the following command:
```
openssl req -x509 -new -nodes -key ca.pri -out selfsigned.cer -config selfsigned.cnf
```
At this point the certificate is ready to be used.

Examine the certificate:
```
openssl x509 -in sscert.cer -noout -text
```

Package the certificate into a pkcs12(.pfx) file:
```
openssl pkcs12 -export -in selfsigned.cer -inkey ca.pri -name "<inset friendly name here>" -out selfsigned.pfx
```

Examine the certificate in pkcs12 format:
```
openssl pkcs12 -info -in selfsigned.pfx
```

Other way to generate the RSA private key and certificate in one go:
```
openssl req -x509 -config selfsigned.cnf -newkey rsa:2048 -nodes -keyout ca2.pri -out selfsigned2.cer
```

Properties that are configured in the configuration file can also be specified as flags:
```
// add custom subject properties

-subj '/CN=Test1/O=Acme Inc./OU=PKI'

-addext "basicConstraints=critical, CA:true, pathlen:1"

-addext "subjectAltName = DNS:acme-inc.com, IP:127.0.0.1"

-addext "keyUsage = critical,digitalSignature,keyEncipherment"

-addext "extendedKeyUsage = critical,codeSigning"

```

## Generate Root CA and issue a certificate

A root CA certificate can be used to issue other certificates creating a trust chain.

The root certificate can be used to validate issued certificates.

A root certificate with a single level of certification is not very common and 
in most cases used on private networks.

Here is a simplified configuration for a single level root ca:
```
[ req ]
default_bits       = 2048
default_md         = sha256
default_days       = 365
distinguished_name = req_distinguished_name
x509_extensions    = v3_ca
prompt             = no

[ req_distinguished_name ]
CN = RootCa1
O  = Root Ca 1 Level
OU = Root Ca 1 Security Department

[ v3_ca ]
# must identify as CA and pathlen:0 so issued certificates cannot issue more
basicConstraints         = critical,CA:TRUE, pathlen:0

# must be eligible for signing
keyUsage                 = critical, keyCertSign, cRLSign

subjectKeyIdentifier     = hash
```
Create a file called `rootca.cnf` with the contents from above.

Generate Root CA and private key:
```
openssl req -x509 -config rootca.cnf -nodes -keyout rootca.pri -out rootca.cer
```

Use this configuration to create a certificate signing request:
```
[ req ]
default_bits       = 2048
default_md         = sha256
default_days       = 365
distinguished_name = req_distinguished_name
x509_extensions    = v3_req
prompt             = no

[ req_distinguished_name ]
CN = localhost
O  = Web Server Certificate
OU = Web Server Certificate Security Department

[ v3_req ]
# must not identify as CA
basicConstraints         = critical,CA:false

# must be eligible for digital signature
keyUsage                 = critical, digitalSignature, keyEncipherment, nonRepudiation

subjectKeyIdentifier     = hash

# must be created for server authentication
extendedKeyUsage         = serverAuth
subjectAltName           = @sans

[ sans ]
DNS.0 = localhost
DNS.1 = 127.0.0.1
```
Create a file called `request.cnf` with the contents from above.

Generate Certificate Request (CSR):
```
openssl req -new -config request.cnf -nodes -keyout webssl.pri -out request.csr
```

Sign Certificate Request (Sign CSR)(And the extensions also from the CSR)
```
openssl x509 -req -in request.csr -CA rootca.cer -CAkey rootca.pri -CAcreateserial -out webssl.cer -extensions v3_req -extfile request.cnf
```
The `webssl.cer` is now ready to be used by a servie to provice a HTTPS connection.

In this scenario the root certificate can be distributed without the private key to client applications and the 
issued certificates can be distributed to server applications.
The root certificate will trust and validate the issued certificates.


## `X.509` theory

TODO 

`X.509` is the format of a Public Key Certificate (Digital certificate).


V1: Serial Number, Algorithm Identifier, Issuer, Subject, Validity, Public Key
V2: Unique Identifier for Issuer and Subject
V3: Extensions

A `X.509` certificate contains 2 important sections:
- TBSCertificate(To be signed certificate)
- Extensions

TBSCertificate section comprises of:
- Version of X.509 certificate(Latest is V3)
- Serial Number
- Signing and Hashing algorithm identifiers
- Subject and Issuer
- Validity date

Certificate Revocation List
- Signed Database of Revoked Certificates
- Always signed by the CA publishing it
- Always timestamped
- Signed database is distributed to Remote client using CDP

Certification Path Validation

Time Stamping
- is used for proving the existence of data at a certain point
- issued by a Time Stamping Authority (TSA)
- Timestamping request is sent to TSA (Time Stamping Request) -> Time Stamping Response
- Time stamping token

Contents of a Digital Certificate
- Purpose of Certificate
- Issued to and Issuer
- Validity Period
- All other details in V1,V2 and V3
- Certification Path -> Certification Chain

## What is a PKI (Public Key Infrastructure) ?


PKI (Public Key Infrastructure)
- Certificate Authority = CA (Issuing, Storing, Managing Digital Certificates)
- Public CA/ Private CA
- Certificates Chain of Trust
- A root CA is always a Self Signed Certificate

- Subordonate CA or Intermediate CA
    - Second to a ROOT CA
    - Uses a certificate signed by the ROOT CA
    - Can issue certificates

## OpenSSL configuration important parts

In this section we describe the sections used in a openssl configuration file
to create a SSL certificate.

### Request section
Here we define the section used for a creation of a certificate.

This section is used by the `req` command.

```
[req]
# Size of cipher Key
default_bits            = 4096

# Hashing algorithm identifier
default_md              = sha256

# Encoding
utf8                    = yes
string_mask             = utf8only

# Subject field
distinguished_name      = ca_dn

# Extensions field
req_extensions          = ca_ext

prompt                  = no
```

The `ca_dn` section contains the Subject (and Issuer if it is a CA) information.

The `ca_ext` V3 extensions of the SSL certificate.

The `prompt` setting is used tell the command to not wait for any prompts.

### CA Distinguished Name

Here we define the Subject (and Issuer if it is a CA) of the certificate.

```
[ ca_dn ]
# Mandatory
CN           = Root CA
C            = US
O            = Example Corp

# Optional
ST           = California
L            = Los Angeles
OU           = Example Corp Security
emailAddress = admin@example.com
```

CN = Common Name C = Country O = Organization Name ST = State L = Location OU = Organization Unit

### CA Default

```
[ ca ]
default_ca = ca_dafault

[ ca_dafault ]
# Path where the CA files and directories are stored
dir               = /home/myuser/ca

# Directory where issued certificates are stored
certs             = $dir/certs
new_certs_dir     = $dir/newcerts

# File that maintains the CA's certificate database
database          = $dir/index.txt

# Serial number to be used for certificate signing
serial            = $dir/serial

# Random data for cryptographic operations
RANDFILE          = $dir/private/.rand

# Path to the private key file used by the CA
private_key       = $dir/private/myrootCA.key

# Specifies the path to the CA's own certificate file
certificate       = $dir/certs/myrootCA.crt

# Specifies the default validity period (in days) for certificates issued by the CA
default_days      = 3650

#CLR
# Directory where the Certificate Revocation List (CRL) files are stored
crl_dir           = $dir/crl

# Specifies the path to the file that maintains the current CRL number
crlnumber         = $dir/crlnum

# Specifies the path to the CRL file generated by the CA
crl               = $dir/crl/mycrl.pem

# Specifies the default validity period (in days) for the CRL
default_crl_days  = 30

# Specifies the policy section that defines the CA's policies
policy            = policy


# TODO
unique_subject    = no
copy_extensions   = none
preserve          = no

prompt            = no
```

### CA Policies

This section is used to check if issued certificates respect
the configured option.

| Value     | Meaning                                                         |
| ---       | ---                                                             |
| supplied  | The field must be supplied                                      |
| match     | The filed must match the ones in the issuing certificate        |
| optional  | These fields are optional, and values do not need to be matched |


```
[policy]
commonName              = supplied

countryName             = match
organizationName        = match

stateOrProvinceName     = optional
organizationalUnitName  = optional
emailAddress            = optional
```

### V3 Extensions

Version 3 of the X.509 introduces extensions. These represent extra 
configurations of a SSL certificate.

TODO 


myrootca.cnf
```
[req]
distinguished_name = dname
x509_extensions = cert_ext
prompt = no

[ dname ]
CN = RootCA
C = AT
ST = Tyrol
L = Zirl
O = ODobre Corp
OU = ODobre Security
emailAddress = octavian@dobre.com

[ cert_ext ]
basicConstraints = CA:TRUE, pathlen:0
keyUsage = keyCertSign, cRLSign
subjectKeyIdentifier=hash
```

mycertificatereq.cnf
```
[req]
distinguished_name = dname
req_extensions = req_ext
prompt = no

[ dname ]
CN = RootCA
C = AT
ST = Tyrol
L = Zirl
O = ODobre Corp
OU = ODobre Security
emailAddress = octavian@dobre.com

[ req_ext ]
basicConstraints = CA:FALSE
keyUsage = digitalSignature, nonRepudiation
extendedKeyUsage = serverAuth, clientAuth
subjectKeyIdentifier=hash
subjectAltName=@sans
certificatePolicies = 1.2.4.5.6.7
authorityInfoAccess = OCSP;http://ocsp.myCA/
authorityInfoAccess = caIssuers;URI:http://myCA/ca.cer

[sans]
DNS.1 = blog.dobre.com
DNS.2 = video.dobre.com
```


## Creating a two-tier PKI with CA and Intermediate CA

TODO

In this section we will combine the knowledge from the previous `theory`, `pki` and `openssl configuration` sections
along with the practice from the previous sections in order to:
- create our own pki
- create a root ca and a issuing ca
- issue certificates ready for web and client auth


### Generate ROOT CA

0. Folder structure
cert/crl/csr/data/issued_certs/private

1. Generate file with random data

```
openssl rand -hex -out private/.rand 16
```

2. Create a file to index all certificates issued by rootCA
```
touch data/index.dat
```
3. Create a serial number
```
openssl rand -hex -out data/serial.dat  8
```
4. Create crl_number file

```
echo "1000" > data/crl_number
```

5. Follow the same stepps for the intermediate CA

6. Creat root configuration
Check files

7. Generate encrypted private key for root CA (choose password)
```
openssl genrsa -aes256 -out private/myRoot.key
openssl ecparam -genkey -name secp521r1 | openssl ec -aes256 -out private/myRoot.key
```

8. Generate root CA certificate
```
openssl req -config myRoot.cnf -new -x509 -sha256 -extensions v3_ca -days 3650 -out cert/myRoot.cer
```

9. Examine the certificate
```
openssl x509 -in cert/myRoot.cer -noout -text
```

10. Generate private key for intermediate CA
```
openssl genrsa -aes256 -out private/myIssuing.key 2048
openssl ecparam -genkey -name secp521r1 | openssl ec -aes256 -out private/myIssuing.key
```

11. Generate certificate request from root CA
```
openssl req -config ../myRoot/myRoot.cnf -key private/myIssuing.key -new -sha256 -out csr/myIssuing.csr
```

12. Sign certificate request with root CA
```
openssl ca -config ../myRoot/myRoot.cnf -extensions v3_intermediate_ca -days 1826 -notext -md sha256 -in csr/myIssuing.csr -out cert/myIssuing.cer
```

13. Create CA bundle file by concatenating the issuing and the root ( issue then root)
```
cert/cacerts.cer
```
14. Verify that the CA bundle is ok
```
openssl verify -CAfile cert/cacerts.cer cert/myIssuing.cer
```
15. Issue a certificate for a server
```
openssl genrsa -aes256 -out webssl.key 2048

openssl req -config ../myIssuing/myIssuing.cnf -key webssl.key -new -sha256 -out webssl.csr -extensions server_cert

openssl ca -config ../myIssuing/myIssuing.cnf -extensions server_cert -days 356 -notext -md sha256 -in webssl.csr -out webssl.cer
```

16. Examine server certificate
```
openssl x509 -in webssl.cer -noout -text
```

## :books: Documentation

[OpenSSL Series](https://www.youtube.com/watch?v=O1OaJmrRHrw&list=PLgBMtP0_D_afzNG7Zs2jr8FSoyeU4yqhi&index=2)

[Certificate Details](https://www.youtube.com/watch?v=oubvJWMcMrA)

[IMB CSR example](https://www.ibm.com/docs/en/hpvs/1.2.x?topic=reference-openssl-configuration-examples)

[Create a CA](https://www.phildev.net/ssl/creating_ca.html)

[RFC 5280 for X509 certificates](https://www.rfc-editor.org/rfc/rfc5280)

[V3 Extensions](https://knowledge.digicert.com/solution/SO18140.html)